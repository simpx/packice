# PackIce v0 Implementation Plan

## Objective
Deliver a minimal, runnable PackIce node implementing the core lease model and three hard APIs (`Acquire`, `Seal`, `Release`) so clients can create, seal, and fetch immutable objects. The focus is correctness of lease semantics and copy-by-composition; distributed resolver integration is deliberately lightweight and advisory.

## Scope (v0 commitments)
- Single binary node process with in-memory object store and attachment buffers.
- Three public APIs surfaced over a simple HTTP+JSON interface:
  - `POST /acquire` with intent flag (`create` or `read`) and `objid` (plus optional metadata) returns `lease_id`, attachment handle token, flags, and optional metadata echo.
  - `POST /seal` with `lease_id` freezes bytes and metadata, transitions the object copy to SEALED, and marks attachment read-only.
  - `POST /release` with `lease_id` ends lease rights and allows eviction.
- Attachments backed by byte buffers keyed by `lease_id`; writable only while the lease is active and unsealed.
- Lease durations tracked via wall-clock TTL; expired leases implicitly behave as released for attachment access.
- Resolver integration mocked with an in-process map (`objid` → candidate node URLs) populated via `Seal` (best-effort, non-authoritative) and used on read miss flow.
- Object metadata stored alongside bytes and frozen on `Seal`; includes optional `prev_objid` for chain linking.
- Minimal logging for API calls and state transitions; debug-level logs for lease acquisition/denial and TTL expiry.

## Non-goals for v0
- Persistent storage or crash recovery.
- Distributed consensus on directory entries; resolver remains soft-state hints only.
- Background lease renewal; all refresh is explicit via new `Acquire` calls.
- Advanced eviction policies (use simple LRU/size cap) and multi-tenant auth.

## Data Model
- **Object Record**: `{ objid, state: CREATING|SEALED, sealed_at?, meta, prev_objid?, sealed_size }`
- **Lease Record**: `{ lease_id, objid, intent: create|read, ttl_deadline, sealed: bool, attachment_id }`
- **Attachment**: byte buffer indexed by `attachment_id`; writable iff the associated lease is active and unsealed.
- Indices: `objid → latest sealed attachment`, `lease_id → lease record`, `attachment_id → buffer`.

## API Semantics (v0 details)
- `Acquire(create)`
  - Fails if an active create lease already exists for the `objid`.
  - Allocates new lease + writable attachment; inserts object in CREATING state.
  - Returns lease metadata (TTL, flags) and attachment token for subsequent writes.
- `Acquire(read)`
  - If sealed copy exists locally and lease TTL can be granted, returns read lease bound to sealed attachment.
  - If absent, performs resolver lookup for candidates and attempts fetch-on-miss copy (see flow below); returns lease bound to the newly sealed local copy on success.
- `Seal`
  - Valid only for active create leases; freezes attachment, updates object state to SEALED, records `sealed_size`, and advertises node to resolver (best-effort).
- `Release`
  - Ends lease and attachment access; for unsealed create leases, drops object + attachment.
  - May trigger eviction if no active leases remain on a sealed copy.

## Copy Flow on Read Miss (composition)
1. `Acquire(objid, read)` fails locally.
2. Resolver returns candidate node URLs (may be stale).
3. For each candidate until success:
   - Attempt `Acquire(objid, read)` on candidate; continue on failure.
   - On success, `Acquire(objid, create)` locally → writable attachment.
   - Stream bytes from candidate attachment to local writable attachment.
   - `Seal` local lease to finalize copy; `Release` both leases.
4. Propagate not-found if all candidates fail.

## Lifecycle & Eviction
- Lease TTL checked on every access; expired leases treated as released.
- Eviction policy: cap total attachment bytes; evict least-recently-used sealed attachments without active leases.
- Re-`Acquire(read)` after eviction performs fetch-on-miss again.

## Usage (developer loop)
- **Start a node (example)**: `PACKICE_PORT=8080 packice-node` (binary serves HTTP on `0.0.0.0:$PACKICE_PORT` and writes attachments under `$PACKICE_DATA/attachments` by default).
- **Create + seal using local files**:
  1. `LEASE_JSON=$(curl -s -X POST http://localhost:8080/acquire -H 'Content-Type: application/json' -d '{"objid":"o1","intent":"create","meta":{"prev_objid":null},"ttl_seconds":60}')`
  2. `LEASE_ID=$(echo "$LEASE_JSON" | jq -r '.lease_id')`
  3. `ATTACH_PATH=$(echo "$LEASE_JSON" | jq -r '.attachment_path')`
  4. `cp bytes.bin "$ATTACH_PATH"` (direct file write instead of POST upload; node reads from this path when sealing)
  5. `curl -s -X POST http://localhost:8080/seal -H 'Content-Type: application/json' -d "{\"lease_id\":\"$LEASE_ID\"}"`
  6. `curl -s -X POST http://localhost:8080/release -H 'Content-Type: application/json' -d "{\"lease_id\":\"$LEASE_ID\"}"`
- **Read using local files**:
  1. `LEASE_JSON=$(curl -s -X POST http://localhost:8080/acquire -H 'Content-Type: application/json' -d '{"objid":"o1","intent":"read","ttl_seconds":30}')`
  2. `ATTACH_PATH=$(echo "$LEASE_JSON" | jq -r '.attachment_path')`
  3. `cat "$ATTACH_PATH" > out.bin` (attachment is read-only; copy it locally)

## Demonstration Flow (end-to-end)
1. Start two nodes: `PACKICE_PORT=8080 packice-node` and `PACKICE_PORT=8081 packice-node`.
2. Write on node A (8080):
   - Acquire-create → copy local file into attachment path → seal → release (commands above with port 8080).
3. Node A best-effort registers itself in the resolver map.
4. Read from node B (8081):
   - `curl -s -X POST http://localhost:8081/acquire -H 'Content-Type: application/json' -d '{"objid":"o1","intent":"read","ttl_seconds":30}'`
   - Node B misses locally, consults resolver, issues read-acquire to A, copies attachment bytes into a local create lease, seals locally, and returns a read lease bound to its sealed copy.
5. Use the returned `attachment_path` on B to read bytes via the filesystem (`cat "$ATTACH_PATH"`); release leases when done.

## Testing Strategy (v0)
- Manual API walks with curl against two local nodes covering:
  - create → write → seal → release
  - read miss resolved via peer copy and local seal
  - eviction behavior under size cap after releases

## Delivery Checklist
- HTTP server exposing three endpoints and shared request/response schema.
- In-memory stores for objects, leases, attachments, and resolver map.
- TTL enforcement and attachment access guards.
- Simple LRU eviction tied to total attachment size.
- Basic logging and metrics counters for API calls and failures.
